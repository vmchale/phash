{-# LANGUAGE ScopedTypeVariables #-}

module Parallel ( Img (..), pathMaps ) where

import           Control.Concurrent.STM      (atomically)
import           Control.Concurrent.STM.TVar (TVar, modifyTVar', newTVarIO, readTVarIO)
import           Data.Functor                (($>))
import           Data.List.NonEmpty          (NonEmpty (..), (<|))
import qualified Data.Map                    as M
import           Data.Word                   (Word64)
import           PerceptualHash              (fileHashDim)
import           System.Directory.Parallel   (parTraverseAll)
import           System.FilePath             (takeExtension)
import           System.IO                   (hPutStrLn, stderr)

imgExtension :: String -> Bool
imgExtension ".jpg" = True; imgExtension ".JPG" = True; imgExtension ".jpeg" = True;
imgExtension ".png" = True; imgExtension ".gif" = True; imgExtension ".hdr"  = True
imgExtension ".pic" = True; imgExtension ".bmp" = True; imgExtension ".TGA"  = True
imgExtension ".tga" = True; imgExtension ".tif" = True; imgExtension ".tiff" = True
#ifdef WEBP
imgExtension ".webp" = True
#endif
#ifdef AVIF
imgExtension ".avif" = True
#endif
imgExtension _       = False

data Img = Img !FilePath !Int !Int

{-# SCC insertHash #-}
insertHash :: FilePath -> M.Map Word64 (NonEmpty Img) -> IO ()
insertHash fp hashes = do
    img <- fileHashDim fp
    case img of
        Right (hash, (h,w)) -> atomically $ M.focus (insertOrMerge (<>) (Img fp h w :| [])) hash hashes
        Left err -> hPutStrLn stderr ("WARNING: skipping " ++ fp ++ "\n" ++ err)

{-# SCC stepMap #-}
stepMap :: M.Map Word64 (NonEmpty Img) -> FilePath -> IO ()
stepMap var fp = insertHash fp var

pathMaps :: [FilePath] -> [FilePath] -> IO [(Word64, (NonEmpty Img))]
pathMaps fps excls = do
    total <- M.newIO
    parTraverseAll (stepMap total) fileFilter (\fp -> pure (fp `notElem` excls)) fps
    atomically $ toList (M.listT total)

    where fileFilter = pure . imgExtension . takeExtension

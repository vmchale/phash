{-# LANGUAGE ScopedTypeVariables #-}

module Parallel ( Img (..), pathMaps ) where

import           Control.Concurrent.STM    (atomically)
import           Data.List.NonEmpty        (NonEmpty (..))
import           Data.Word                 (Word64)
import           Focus                     (insertOrMerge)
import           ListT                     (toList)
import           PerceptualHash            (fileHashDim)
import qualified StmContainers.Map         as M
import           System.Directory.Parallel (parTraverseAll)
import           System.FilePath           (takeExtension)
import           System.IO                 (hPutStrLn, stderr)

imgExtension :: String -> Bool
imgExtension ".jpg" = True; imgExtension ".JPG" = True; imgExtension ".jpeg" = True;
imgExtension ".png" = True; imgExtension ".gif" = True; imgExtension ".hdr"  = True
imgExtension ".pic" = True; imgExtension ".bmp" = True; imgExtension ".TGA"  = True
imgExtension ".tga" = True; imgExtension ".tif" = True; imgExtension ".tiff" = True
#ifdef WEBP
imgExtension ".webp" = True
#endif
#ifdef AVIF
imgExtension ".avif" = True
#endif
imgExtension _       = False

data Img = Img !FilePath !Int !Int

{-# SCC stepMap #-}
stepMap :: M.Map Word64 (NonEmpty Img) -> FilePath -> IO ()
stepMap hashes fp = do
    img <- fileHashDim fp
    case img of
        Right (hash, (h,w)) -> atomically $ M.focus (insertOrMerge (<>) (Img fp h w :| [])) hash hashes
        Left err -> hPutStrLn stderr ("WARNING: skipping " ++ fp ++ "\n" ++ err)

pathMaps :: [FilePath] -> [FilePath] -> IO [(Word64, (NonEmpty Img))]
pathMaps fps excls = do
    total <- M.newIO
    parTraverseAll (stepMap total) fileFilter (\fp -> pure (fp `notElem` excls)) fps
    atomically $ toList (M.listT total)

    where fileFilter = pure . imgExtension . takeExtension
